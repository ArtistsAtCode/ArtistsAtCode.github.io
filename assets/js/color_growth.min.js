let colorGrowth=function(e,t,o,n,r){const l=o||Math.floor(1e4*Math.random());return[function(o){class a{constructor(){this.head=null,this.tail=null,this.size=0}enqueue(e){let t={value:e,next:null};this.head?(this.tail.next=t,this.tail=t):(this.head=t,this.tail=t),this.size+=1}dequeue(){if(!this.head)return null;const e=this.head;return this.head===this.tail&&(this.tail=null),this.head=this.head.next,this.size-=1,e.value}}class i{constructor(e,t){this.x=e,this.y=t}}class s{constructor(e,t,o){this.red=e,this.green=t,this.blue=o}}class h{constructor(){this.unmutated=!0,this.waitingToBePainted=!1,this.myColor=void 0,this.potentialOrphan=!1}mutateColor(e,t){this.unmutated=!1;let o=this.myColor?this.myColor.red:-1,n=this.myColor?this.myColor.green:-1,r=this.myColor?this.myColor.blue:-1,l=d(e,t);return o+=l.red,n+=l.green,r+=l.blue,o=u(o,0,255),n=u(n,0,255),r=u(r,0,255),this.myColor=new s(o,n,r),this.myColor}blendColor(e,t){this.unmutated=!1;const o=(e.red+t.red)/2,n=(e.green+t.green)/2,r=(e.blue+t.blue)/2;return this.myColor=new s(o,n,r),this.myColor}addColors(e,t){const o=u(e.red+t.red,0,255),n=u(e.green+t.green,0,255),r=u(e.blue+t.blue,0,255);return this.myColor=new s(o,n,r),this.myColor}updateColor(e){return this.unmutated=!1,this.myColor=e,this.myColor}}function u(e,t,o){return Math.max(Math.min(e,Math.max(t,o)),Math.min(t,o))}function d(e,t){if(t){let t=Math.floor(o.random(-1*e,e+1))/2;return new s(t,t,t)}{let t=Math.floor(o.random(-1*e,e+1))/2,n=Math.floor(o.random(-1*e,e+1))/2,r=Math.floor(o.random(-1*e,e+1))/2;return new s(t,n,r)}}function c(e){if(e){let e=Math.floor(random(0,256));return new s(e,e,e)}{let e=Math.floor(o.random(0,256)),t=Math.floor(o.random(0,256)),n=Math.floor(o.random(0,256));return new s(e,t,n)}}const m=0,f=5,w=Math.floor(1e3/18-5),g=new Array,C=new a;let y=new class{constructor(e,t){this.width=e,this.height=t,this.totalPixels=e*t,this.values=new Array(e);for(var o=0;o<e;o++){let e=new Array(t);for(var n=0;n<t;n++)e[n]=new h;this.values[o]=e}}allCoordinates(){const e=new Array(width*height);let t=0;for(var o=0;o<width;o++)for(var n=0;n<height;n++)e[t]=new i(o,n),t+=1;return e}getNode(e){return this.isCoordinateInBounds(e)?this.values[e.x][e.y]:null}randomUnmutatedNeighbors(e,t,n,r){const l=[];[new i(-1,1),new i(0,1),new i(1,1),new i(1,0),new i(1,-1),new i(0,-1),new i(-1,-1),new i(-1,0)].forEach(t=>{const o=new i(e.x+t.x,e.y+t.y),n=this.getNode(o);n&&n.unmutated&&(r&&(n.potentialOrphan=!0),l.push(o))});const a=Math.floor(o.random(t,n+1));return function(e,t){if(t>e.length)return e;if(t<0)return[];let n=new Set(e),r=new Array;for(;r.length<t;){let e=o.random(Array.from(n));r.push(e),n.delete(e)}return r}(l,a)}findAdjacentColor(e){const t=[];return[new i(-1,1),new i(0,1),new i(1,1),new i(1,0),new i(1,-1),new i(0,-1),new i(-1,-1),new i(-1,0)].forEach(o=>{const n=new i(e.x+o.x,e.y+o.y),r=this.getNode(n);r&&0==r.unmutated&&t.push(n)}),t.length?this.getNode(o.random(t)).myColor:null}isCoordinateInBounds(e){return e.x>=0&&e.x<this.width&&e.y>=0&&e.y<this.height}}(e,t),M=!1,p=!1,v=!1,x=0,b=5,P=100,N=!1,q=!1,B=new a,S=0,A=0,z=0;o.setup=function(){o.randomSeed(l),o.frameRate(18),o.createCanvas(e,t);const n=Math.floor(o.random(1,5));S=n;let a=!0;for(var s=0;s<n;s++){const n=new i(Math.floor(o.random(0,e)),Math.floor(o.random(0,t)));g.push(n);const r=c(q);y.getNode(n).updateColor(r),a&&(a=!1,o.background(o.color(r.red,r.green,r.blue)))}b=Math.floor(o.random(5,21)),P=Math.floor(o.random(60,101)),Math.floor(o.random(1,1001))<=1?(q=!0,N=!0):Math.floor(o.random(1,1001))<=50?N=!0:Math.floor(o.random(1,1001))<=20&&(q=!0),r&&(console.log("Seed: "+l),console.log("Start points: "+n),console.log("R Shift: "+b),console.log("Completion: "+P),console.log("Mono growth: "+N),console.log("Mono base: "+q),console.log("Max growth: "+f))},o.draw=function(){z=o.millis();let e=!1;for(let t=0;t<1;t++){const t=C.dequeue();for(;t&&t.size>0;){let n=t.dequeue();const r=y.getNode(n);o.set(n.x,n.y,o.color(r.myColor.red,r.myColor.green,r.myColor.blue)),r.waitingToBePainted=!1,e=!0}}e&&o.updatePixels(),M&&0==C.size&&(p=!0),p&&!v?function(){v=!0;for(var e=0;e<y.width;e++)for(var t=0;t<y.height;t++){const o=new i(e,t),n=y.getNode(o);if(n.unmutated&&n.potentialOrphan){const e=y.findAdjacentColor(o);e&&(n.addColors(e,d(b,N)),B.enqueue(o))}}B.size>0&&(C.enqueue(B),B=new a)}():p&&v&&(o.noLoop(),y=null,n&&o.saveCanvas("color_growth_seed-"+l,"png")),M||function(){if(!M){for(;g.length>0;){const e=Math.floor(o.random(0,g.length)),t=g[e];g.splice(e,1);const n=y.getNode(t),r=n.mutateColor(b,N);n.waitingToBePainted||(n.waitingToBePainted=!0,B.enqueue(t)),S-=1;const l=(x+=1)/y.totalPixels*100;let s=P-l<5;const h=y.randomUnmutatedNeighbors(t,m,f,!s);h.forEach(e=>{g.push(e);const o=new i(2*e.x-t.x,2*e.y-t.y),n=y.getNode(e);y.isCoordinateInBounds(o)&&0==y.getNode(o).unmutated?n.blendColor(r,y.getNode(o).myColor):n.updateColor(r),n.waitingToBePainted||(n.waitingToBePainted=!0,B.enqueue(e)),A+=1}),S<=0&&(C.enqueue(B),B=new a,S=A,A=0);let u=o.millis()-z;if(u>w)return;if(l>=P)return void(M=!0)}M=!0}}()}},l]},currentP5=null,currentSeed=null;function startNewRender(e,t,o){const n=Math.floor(t),r=Math.floor(e);currentP5&&currentP5.remove();const[l,a]=colorGrowth(r,n,o,!1,!0);currentSeed=a,currentP5=new p5(l,"container")}function saveImage(){currentP5&&currentSeed&&currentP5.saveCanvas("color_growth_seed-"+currentSeed,"png")}